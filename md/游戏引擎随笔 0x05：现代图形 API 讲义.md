> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/73016473)

写在前面
----

这篇文章的原来的标题叫 “基于现代图形 API 的并行渲染”，提纲也早就写好，但一直没有落笔，主要是希望能有实践经验再写会更加稳妥一些。上月底完成了 Direct3D12 的渲染后端，开始 Vulkan 后端的接入，恰好最近要做个关于现代图形 API 的培训讲座，结合实践经验，于是写下这篇文章，同时也作为培训 PPT 的参考内容。

**传统图形 API: Direct3D\OpenGL（ES）**
---------------------------------

**简介**

传统 API 诞生于 90 年代，至今已经近 30 年。其设计哲学主要以兼容性、易用性。Direct3D 是微软 DirectX 体系中的一个组件，主要用于 3D 实时渲染功能，OpenGL 是 Khronos 组织推出的用于实时渲染的图形 API，OpenGLES 是该组织在 OpenGL 基础上简化的用于在移动平台实时渲染 API。

**传统图形 API 的特点**

_管线状态是隐式的、全局的_

所谓隐式是指相对于应用层来说，管线的当前状态隐藏在 API（Runtime\Driver）内部，应用程序无法精准的控制管线当前状态。虽然提供了获取当前状态接口，但几乎所有的官方文档中都建议不要频繁调用这些接口，以避免由于获取状态导致额外的调用开销。

_频繁的 API 调用_

由于整个图形 API 渲染管线是基于状态的，所以应用程序必须频繁的调用 API 来设置管线状态和恢复状态，这就使得 API 调用导致的 CPU 开销也成为了渲染瓶颈。尽管在 D3D11 或者 OpenGL4.x 的版本中优化了 API 的调用开销（比如：GL_ARB_multi_bind、GL_ARB_texture_storage 扩展等），但应对更加复杂渲染逻辑就显得杯水车薪了。

_状态切换开销_

传统 API 会对每个渲染状态的设置进行校验和二次处理，比如合并状态统一提交，这样就造成了状态的切换也有一定的开销。减少状态的切换往往是传统 API 的应用必须要考虑的事情，开发者们也各显神通。记得我在 06 年开发第一款商业引擎时，曾经设计了 Render State Tree（将材质对应的状态根据状态切换开销构建树，树的顶端是开销最大的状态，树的叶节点是开销最小的状态，渲染时遍历这棵树，到达树的叶节点时执行真正的 DC）。还有将状态编码进行排序的等各种方法，但无论哪种方法，本质上都是在 CPU 端做额外的预处理工作来换取 GPU 的时间。

在现代 GPU 硬件上，分散的状态设置成为了性能提升的障碍。例如，新型 GPU 会将这些固定管线状态合并成单一硬件状态。但由于 API 允许单独设置这些管道状态，因此 Driver 很可能在运行时为不同的状态组合创建、查找缓存内部的管线状态集合，这很可能会导致管线卡顿，同时额外增大了开销。

![](https://pic3.zhimg.com/80/v2-deb8658f39f221054295f544fe28e8b2_1440w.webp)

_复杂的驱动层逻辑_

为了体现易用性的设计哲学，传统 API 的 Driver 往往都带有非常复杂的逻辑，在 Driver 内部维护跟踪状态，自动管理资源及调度，以及进行运行时的校验，以保证渲染正确。同时为了便于调试，图形 API 的获取错误接口（glGetError） 也需要正确的返回错误，但也增加了 CPU 开销。此外，Driver 还要负责 CPU 与 GPU 的同步，以保证 API 的简洁性，这也是 “隐式” 的一种体现。典型的例子如动态更新 GPU Buffer 数据，如果此时 GPU 正在使用这个 Buffer，则 Map\Lock 之后 API 返回的是 Runtime\Driver 内部动态创建的新内存地址，以更新新数据，当 GPU 使用完旧内存后，再使用新数据。这种管理方式尽管在应用看来是简单的，但不一定是性能最佳的方式。另外，API 的提示标记并不能保证 Driver 一定按照预想的方式执行，Driver 会根据自身当前的状态来决定，比如上述情况，即使在 Map 时指定了 Discard，也不能完全保证运行时 CPU 和 GPU 是完全异步的。

另一种 “隐式” 的体现是 GPU 资源的状态跟踪与同步，比如当前渲染阶段的 Render Target ，也许会成为下一个渲染阶段所使用的 Shader 可访问的纹理资源（典型的如后处理中的 Scene Texture），为了维护资源状态的正确，就需要使用 GPU 内部的同步机制如 Resource Barrier 来保证渲染次序。但这样的“隐式“行为导致应用程序无法深入到内部以最优化的方式减少同步，也无法进一步提升同步性能。

_Shader 的编译_

Direct3D 使用独立的编译模块（D3DCompiler_XX.dll）编译 Shader，这个编译其实是将 Shader 编译为中间结果（谓之 DXBC），这样可在创建 D3D Shader 时将 DXBC 再送入到 Driver 中进行二次编译，编译为 GPU 硬件相关的特定的二进制指令执行。这个过程可以离线预编译，也可以在线编译，但是会有额外的 DXBC 编译开销，造成不必要的管线停顿。

而 OpenGL/ES 则采用了另一种方式，将 Shader 编译交给驱动完成，这样就会导致每次编译时带来的不必要的语法分析以及校验开销，而无法像 D3D 那样通过经过验证的、标准的中间编译结果来获得编译上的性能优势。虽然可以通过扩展来实现预编译功能，但有些平台并不支持，比如 iOS。

_隐式的渲染工作提交_

传统 API 渲染工作的提交一般情况下是 Runtime\Driver 内部执行的，比如当内部的 Render Command Buffer 已满或者 CPU 端通过 Map 访问或者写入资源数据时，Runtime\Driver 会自动提交当前的渲染工作，并等待 GPU 完成。由于这种隐式的机制，导致应用程序很难做到最优化的 CPU、GPU 同步。

随着硬件的发展和新渲染技术的出现，传统 API 也在不断进化，但为了保持兼容性，接口越来越复杂，甚至同一个功能可以有多个方式实现，造成驱动维护上的困难以及开发者使用上的困惑，与当初的设计思想偏离越来越远，甚至是矛盾的，业界迫切需要适应现代图形硬件的，满足复杂渲染需求的全新图形 API。

现代图形 API：Direct3D12\Vulkan\Metal
--------------------------------

**简介**

2014 年微软发布了全新一代图形 API 组件 Direct3D 12，同年 Apple 也发布了运行于 iOS\MacOS 平台的全新的图形 API Metal，2015 年 khronos Group 发布了 OpenGL 的继任者：Vulkan。

现代的 API 以更加显式的管理、更贴近于硬件的接口，给与开发者更大的自由度为其指导设计哲学。从接口来看，Vulkan 和 Metal 是全新的 API 设计，D3D12 的绝大部分的接口都重新设计，少量还存在的接口的概念也不尽相同。

**现代图形 API 的特点**

_低消耗的状态切换_

新 API 使用 PipelineState 将管道状态提前创建并绑定，在渲染时，通过设置不同的 PipelineState，Driver 只需要少量的切换开销即可将预先创建的状态绑定到 GPU 中，而无需像传统 API 那样校验每种状态有效性以及动态合并状态，从而降低了绘制调用开销，并且可以大幅增加每帧的绘制调用次数。

![](https://pic4.zhimg.com/v2-2fc0d9a6954953df89e67e3ef37682a3_r.jpg)

_预置的 Shader 资源布局和绑定_

通过 RootSingature（D3D12）或者 PipelineLayout（Vulkan）通过 Descriptor 预先设置好 Shader 所需要使用的资源布局信息，包括：Constant、Texture（SRV）、Buffer（UAV）、Sampler 等，在渲染时 Shader 通过 DescriptorTable 或者 DescriptorSet 用间接寻址方式获取资源，无需渲染时绑定，大大降低了资源绑定和校验开销，从而提高了渲染性能。

![](https://pic1.zhimg.com/v2-b54e9aa0481d4565bcfc5a07e276b224_r.jpg)![](https://pic4.zhimg.com/v2-f3ed87a33ba1005f4bbf7606d08500df_r.jpg)

Metal 虽然也有 PipelineState，但并没有提供指定 Shader Resource Layout 的机制，绑定 Shader 资源时和传统 API 类似，使用 setFragmentTexture\setVertexTexture 之类的函数设置。

_显式的资源状态管理_

现代 API 通过使用资源屏障（Resource Barrier）来要求应用层明确控制资源的状态迁移， Runtime\Driver 不再通过提示、假设或猜想进行自动的状态跟踪和维护，而是完全由开发者来管理资源状态。这使得开发者能很明确的了解所使用的资源当前状态，可以更高效的控制状态迁移，从而提升性能。

_更加显式的渲染工作提交和 CPU/GPU 同步控制_

如上文所述，传统 API 是隐式提交渲染工作以及同步，现代 API 则提供了显式的控制渲染提交和同步控制接口。应用程序通过使用 Command List（D3D12）或 Command Buffer（Vulkan\Metal）录制渲染命令，再通过 Command Queue 提交到 GPU 中执行。

CPU 和 GPU 的同步是通过 Fence 对象和 WaitFence 函数完成，整个过程完全由应用程序来控制，这样应用程序可以根据需要，更加精准的控制同步时机，从而实现 CPU/GPU 最大化并行性能。

_提供显式的 CPU/GPU 堆内存管理_

传统的 API 的内存管理是隐式的，当创建资源时 Runtime\Driver 内部也同时创建用于这个资源的内存，这个过程对开发者是透明的，尽管接口简单，但带来的问题是很难优化内存分配，并且容易造成 GPU 内存碎片。新 API 都提供了 CPU/GPU 堆内存管理接口，可以通过创建堆，在堆上分配空间的方式来创建资源，应用程序可以精准的控制资源堆内存的分配。比如可以通过资源别名（在同一堆空间中创建不同的资源），在不同的时段可重复利用同一的设备内存来完成渲染逻辑，从而更有效的使用有限的 GPU 内存资源。

![](https://pic1.zhimg.com/v2-2be91343f66a305ee7a93e6247700be0_r.jpg)

_显式的资源生命周期控制_

在传统 API 中释放资源一般是隐式的，比如在 D3D11 中，即使资源引用计数为 0，其 Runtime 也并不是立即释放这个资源，因为此时 GPU 使用这个资源的渲染工作可能还没有完成或者正在执行中。新的图形 API 明确要求应用程序必须在确保渲染命令不再使用资源时才能释放，虽然增加了资源管理的复杂度，但大大提升了资源生命周期的控制精度。

_并行提交渲染工作_

现代 API 都增加了 Command List 或 Command Buffer 记录渲染指令，再通过 Queue 提交到 GPU 中，而每个 Command List\Buffer 都可以在不同的线程中单独填充，这意味着可以并行录制渲染指令，充分发挥了现代 CPU 多核的并行能力。甚至还可以创建多个异步计算或者上传数据的 Command Queue，利用 GPU 的并行机制实现渲染和计算、上传数据的并行。这也意味着可以有更多的可能以充分利用硬件性能实现性能更高的渲染逻辑，在下文中会有详细说明。

_Shader 预编译机制_

如上文所述传统 API 中只有 D3D 提供了统一的 Shader 预编译功能，新一代图形 API 则全部提供了这个机制，在 D3D12 中 DXBC 进化为 DXIL，Vulkan 提出了 SPIR-V 标准，可将 GLSL 编译为 SPIR-V 中间格式，Metal 由于只运行在单一平台，自然也提供了预编译 Shader 机制。

_实时 GI_

*   微软在 2018 年 发布了 Direct3D 12 RayTracing API，这也是三者中目前最成熟方案。
*   Vulkan 的 RT 目前还是草案，使用的是 Nvidia 贡献的 RayTracing 扩展 VK_NV_ray_tracing，Khronos RayTracing TSG 的目标是形成标准的扩展，同时完全兼容 DXR。
*   Metal API 有基于 Performance Shader 的加速 RayTracing 方案，可以运行在 iOS12 以上的移动平台。

_显式的多 GPU 支持_

这三者都支持多 GPU，不限于连接方式，无论是分离还是集成的，甚至是异构 GPU 都可以充分利用，但目前都仅限于桌面平台。

_机器学习_

同实时 GI 一样，新一代 API 也都有各自的 ML 方案，这里简单罗列，不再详述：

*   D3D12：DirectML
*   Vulkan：Vulkan ML
*   Metal：基于 Performance Shader 的 ML

基于现代图形 API 开发的挑战
----------------

经过上述说明，可以看到现代 API 是更加显式、和低级（接近硬件）的，虽然这个设计哲学目的是最大化提高实时渲染性能，但为了实现这一点却并非易事。如果只是简单地移植，最终的性能恐怕还不如传统 API。

要在现代 API 基础上实现更好的性能，需要更多更复杂的图形管线管理开发工作。由于是显式的，更接近图形硬件的设计，现代 API 的驱动不再负责传统 API Driver 复杂的内部逻辑，但这些工作并不是自动消失，而是转移到应用层，由开发者负责。可以粗略地认为，基于现代 API 的管线管理要负责相当一部分传统 API 驱动的职责。下图直观的说明了在传统 API 上和现代 API 上图形管线管理开发工作量的比较：

![](https://pic2.zhimg.com/v2-e87ae6be3d0c4ed8d432044af79bb795_r.jpg)

这些工作量包括：

*   **重新设计图形 API 抽象接口**，以往基于传统 API 的接口已不再适合，比如管线状态，以前可能分为 Vertex Layout、Blend、Sampler、DethStencil、Rasterizer 等，现代 API 已经将这些状态合并，所以需要抽象一个 PipelineState 来表示和设置。另一个例子是 Command List，需要抽象层提供这样的抽象对象，供高层逻辑来录制图形指令，实现并行渲染。其他的还有资源屏障等，也是抽象并开放给应用层。
*   **堆内存管理**，包括 GPU 和 CPU 内存，精细控制内存预算和跟踪内存分配和使用，甚至还要根据不同使用场景来定制内存管理策略。比如根据 GPU 是否只读、CPU 是否只读、CPU\GPU 的写入频率等，不同的情况需要对应不同的内存管理策略，充分利用 GPU 的 Copy\Upload\Transfer 硬件引擎完成数据传输，才能实现最佳的性能。
*   **描述符（Descriptor）管理**，在传统 API 上绑定 Shader 资源只需要简单调用形如 SetTexture\SetConstant\SetSampler 之类的接口即可，而在现代 API 中，通过 Shader 所需要使用的资源布局信息是预置的（前文所述），渲染时需要通过 Descriptor 来间接寻址资源，由于 Descriptor 也是一种 API（GPU 硬件） 资源，一般来说 GPU 可见的 Descriptor 是有限的（硬件相关限制），渲染时需要对有限的 GPU Descriptor 使用有效的管理方式加以重用，才能完成复杂的渲染逻辑。另外由于并行渲染的存在，Descriptor 的分配和释放还要考虑到线程同步，如何在并行中减少线程同步所带来的开销也是需要仔细考虑的问题，这进一步增加了管理复杂度。
*   **渲染帧管理**，为了最大化并行 CPU\GPU，Swapchain 通常需要创建多个 back Buffer，这样 GPU 绘制当前帧（或者上一帧），CPU 可以并行填充绘制下一帧的命令，在开始录制每个 Frame 的渲染指令时，可以通过这一帧上一次绘制的 GPU Fence 查询 GPU 是否完成上一次渲染，如果完成则开始录制逻辑，否则等待。要达到这样的结果，每个 Frame 需要有自己的 CommandList 和相关的 GPU 资源，这就需要实现渲染帧逻辑，还需要在提交到 GPU 渲染时对 Frame 进行调度管理。

![](https://pic4.zhimg.com/v2-5885fd2a744841b6468be119ae1d9e07_r.jpg)

*   **API 对象的生命周期控制**，要保证 API 渲染、计算管线中在使用对象的过程中不能释放对象。比如上层逻辑在 Frame2 中释放某个对象，但这个对象还在 Frame1 中被使用，则此时不能执行真正的释放，需要通过 GPU Fence 事件通知或者轮询方式等到 Frame1 执行完成才能释放。
*   **并行提交绘制指令，**现代 API 的 Command List 都是 Thread Free 的，所以可以实现多个线程并行填充绘制、计算指令，以达到并行提交渲染工作的的目的。要实现这一点，一般是由 Task System 或者 Job System 来完成，在[我的上一篇文章 “并行计算架构”](https://zhuanlan.zhihu.com/p/71688066) 中有详细的阐述，这里不再赘述。

由于篇幅限制，以上这些内容的具体实现细节不是本文的讨论的范围，这里只是简单说明，以后有机会可以单独写一篇来详细阐述。

基于现代图形 API 的渲染管线设计
------------------

**GPU 并行架构**

利用并行提交特性，渲染管线可设计为多线程结构，可根据当前 CPU 硬件线程数量动态决定 CommandList\Buffer 的数量，这样在架构上也是可缩放的。

另外，现代 GPU 其内部都会有多个专用于不同功能的 GPU 硬件引擎，一般有图形（3D）、计算（Compute）、Copy（Transfer）三种，这三者在 GPU 内部可并行执行，如下图所示：

![](https://pic3.zhimg.com/v2-b38aef28fb7901def0333a6fe211ba12_r.jpg)

利用这个机制可以将管线设计为这样：

![](https://pic2.zhimg.com/v2-6647fa57ba10d9e59ef450c95a5465e9_r.jpg)

如图所示，图形（3D）队列负责 PreZ、GBuffer、Shadow 等场景渲染，同时计算队列负责计算后处理（SSAO、Bloom、ToneMapping、AA 等等），Copy 队列同时执行纹理 Streaming 或者 Virtual texture 等操作。这些都可以在 GPU 时间线上同时进行，大大提高了渲染管线的性能。

**进一步优化 Render Graph**

通过检查渲染帧内的资源依赖关系，利用别名资源重复利用内存堆，优化 GPU 内存资源使用。如下所示：

![](https://pic2.zhimg.com/v2-a69ef401111d7e4daafba86bb45dc8e5_r.jpg)

**GPU 驱动的渲染管线**

利用间接绘制 \ 计算（IndirectDraw\IndirectCompute），可实现渲染时更少的 CPU/GPU 之间的切换，在 CPU 中准备场景数据，一次性提交到 GPU 中，使用 GPU 进行可见性剔除，并填充 CommandList/Buffer，这样可以将传统的 CPU 负担的工作交由 GPU 执行，降低 CPU 的负载，甚至可以进行更高精度级别的可见性剔除。

![](https://pic3.zhimg.com/v2-e31bb10597a4e179fa58b6c8ef2bc73e_r.jpg)

总之，通过现代图形 API 新特性，可以使原有管线功能更加优化，甚至有更多的想象空间，创造出新的渲染技术路线。

写在后面
----

最近一直在做新渲染引擎的 D3D12 和 Vulkan 的渲染后端，有感于现代图形 API 的复杂度，以往接入传统 API 只需几天或者顶多 1~2 周即可完成，但现在仅仅是 D3D12，我从开始学习到最后完成接入，用了将近 2 个月的时间。以往的 API 经验几乎都用不上，甚至由于思维定式，还会成为理解新 API 的阻碍。现代 API 对开发者要求很高，需要有坚实的内存管理基础，丰富的多线程同步经验和架构设计经验，大量的图形知识，以及专业的内存级别的编程技能。尽管如此复杂，但是从发展的角度来说这些付出是完全值得的，传统 API 必将被摒弃，现代 API 结合现代 GPU 硬件才能发挥更大价值，硬件、API 层的变革推动了引擎层面的变革。并行计算架构、可扩展的渲染管线、GPU 驱动的渲染管线、RayTracing 甚至机器学习等新的技术将会成甚至已经成为新一代游戏的标配。只有学习和实际应用，才能紧跟时代的步伐。